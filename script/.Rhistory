rm(list = ls())
# inverse hyperbolic sine transformation
ihs <- function(x){
x.ihs <- log(x + sqrt(x^2 + 1))
return(x.ihs)
}
# generate sample data
set.seed(8675309)
N <- 10000
beta1 <- 1.5
d <- data.frame(x1=sample(-10:100, N, replace=TRUE)/10)
d$epsilon <- rnorm(N,0,5)
d$y <- with(d, 0.5 + beta1*x1 + epsilon)
summary(d$y)
summary(d$x1)
summary(d$epsilon)
hist(d$y)
plot(d$x1, d$y)
# replace y<0 with zeros & subset to positive values of y
d$y[d$y<0] <- 0
d.pos <- subset(d, y > 0)
summary(d$y)
summary(d.pos$y)
hist(log(d.pos$y))
beta1.pct <- beta1/mean(d$y)
beta1.pct.pos <- beta1/mean(d.pos$y)
# generate alternative dependent variable specifications
d$y.log <- log(d$y+1)
d$y.ihs <- ihs(d$y)
# linear models
fit.lin  <- lm(y~x1, data=d)
fit.pos  <- lm(y~x1, data=d.pos)
fit.log  <- lm(y.log~x1, data=d)
fit.ihs  <- lm(y.ihs~x1, data=d)
# sample percentage effect
pct.lin <- as.numeric(fit.lin$coefficients['x1'] / mean(d$y))
pct.pos <- as.numeric(fit.pos$coefficients['x1'] / mean(d.pos$y))
pct.log <- as.numeric(fit.log$coefficients['x1'])
pct.ihs <- as.numeric(fit.ihs$coefficients['x1'])
#summary(fit.lin)
#summary(fit.pos)
#summary(fit.log)
#summary(fit.ihs)
pct <- rbind(beta1.pct, beta1.pct.pos, pct.lin, pct.pos, pct.log, pct.ihs)
colnames(pct) <- c('Percentage Effect')
print(pct)
e.lin <- as.numeric(fit.lin$coefficients['x1'] * mean(d$x1) / mean(d$y))
e.pos <- as.numeric(fit.pos$coefficients['x1'] * mean(d.pos$x1) / mean(d.pos$y))
e.log <- as.numeric(fit.log$coefficients['x1'] * mean(d$x1))
e.ihs <- as.numeric(fit.ihs$coefficients['x1'] * mean(d$x1) / mean(d$y) *
cosh(mean(fit.ihs$coefficients[1]) + fit.ihs$coefficients['x1']*mean(d$x1)))
mean(fit.ihs$coefficients[1])
hist(fit.ihs$residuals)
